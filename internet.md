1. 描述一下一次HTTP请求从请求到返回的过程,越详细越深入越好</br>
1)把URL分割成几个部分:协议、网络地址、资源路径。 其中网络地址指示该连接网络上哪一台计算机,可以是域名或者IP地址,可以包括端口号; 协议是从该计算机获取资源的方式,常见的是HTTP、FTP,不同协议有不同的通讯内容格式;资源路径指示从服务器上获取哪一项资源。 例如:http://www.guokr.com/question/554991/</br>
协议部分:http</br>
网络地址:www.guokr.com</br>
资源路径:/question/554991/</br>
2)如果地址不是一个IP地址,通过DNS(域名系统)将该地址解析成IP地址。 IP地址对应着网络上一台计算机,DNS服务器本身也有IP,你的网络设置包含DNS服务器的IP。 </br>
例如:www.guokr.com 不是一个IP,向DNS询问请求www.guokr.com 对应的IP,获得IP: 111.13.57.142。 这个过程里,你的电脑直接询问的DNS服务器可能没有www.guokr.com 对应的IP,就会向它的上级服务器询问, 上级服务器同样可能没有,就依此一层层向上找,最高可达根节点,找到或者全部找不到为止。 (DNS缓存和解析过程是一个考察点,有些面试者能叙述出完整的过程,有些只能给出笼统的结果,以下是DNS缓存策略)</br>
浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是,操作系统没有告诉浏览器储存DNS记录的时间,这样不同浏览器会储存个自固定的一个时间(2分钟到30分钟不等)。 </br>
系统缓存 – 如果在浏览器缓存里没有找到需要的记录,浏览器会做一个系统调用(windows里是gethostbyname)。这样便可获得系统缓存中的记录。</br>
路由器缓存 – 接着,前面的查询请求发向路由器,它一般会有自己的DNS缓存。 </br>
ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。 </br>
递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索,从.com顶级域名服务器到Facebook的域名服务器。一般DNS服务器的缓存中会有.com 域名服务器中的域名,所以到顶级服务器的匹配过程不是那么必要了。 </br>
3)如果地址不包含端口号,根据协议的默认端口号确定一个。 </br>
端口号之于计算机就像窗口号之于银行,一家银行有多个窗口,每个窗口都有个号码,不同窗口可以负责不同的服务。</br> 
端口只是一个逻辑概念,和计算机硬件没有关系。 </br>
例如:www.guokr.com 不包含端口号,http协议默认端口号是80。 </br>
如果你输入的url是http://www.guokr.com:8080/ ,那表示不使用默认的端口号,而使用指定的端口号8080。 </br>
4)向2和3确定的IP和端口号发起网络连接。 例如:向111.13.57.142的80端口发起连接 </br>
5)根据http协议要求,组织一个请求的数据包,里面包含大量请求信息,包括请求</br>的资源路径、你的身份 例如:用自然语言来表达这个数据包,大概就是:请求 /question/554991/ ,我的身份是xxxxxxx。 
6)服务器响应请求,将数据返回给浏览器。数据可能是根据HTML协议组织的网页,里面包含页面的布局、文字。数据也可能是图片、脚本程序等 。现在你可以用浏览器的“查看源代码”功能,感受一下服务器返回的是什么东东。如果资源路径指示的资源不存在,服务器就会返回著名的404 错误。 </br>
7)如果(6)返回的是一个页面,根据页面里一些外链的URL,例如图片的地址,按照(1)-(6)再次获取。 </br>
8)开始根据资源的类型,将资源组织成屏幕上显示的图像,这个过程叫渲染,网页渲染是浏览器最复杂、最核心的功能。 </br>
9)将渲染好的页面图像显示出来,并开始响应用户的操作。 </br>

2. OSI七层协议</br>
应用层 表示层 会话层 传输层 网络层 数据链路层 物理层</br>

3. TCP/IP五层模型协议</br>
应用层 传输层 网络层 数据链路层 物理层</br>

4. http状态码</br>
100-199 用于指定客户端应相应的某些动作。 </br>
200-299 用于表示请求成功。 </br>
300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 </br>
400-499 用于指出客户端的错误。 </br>
500-599 用于支持服务器错误</br>
502 Bad Gateway:作为网关或者代理工作的服务器尝试执行请求时,从上游服务器接收到无效的响应。 </br>
504 Gateway Time-out:作为网关或者代理工作的服务器尝试执行请求时,未能及时从上游服务器(URI标识出的服务器,例如HTTP、FTP、LD AP)或者辅助服务器(例如DNS)收到响应。 </br>
502 Bad Gateway:Tomcat没有启动起来 </br>
504 Gateway Time-out: Nginx报出来的错误,一般是Nginx做为反向代理服务器的时候,所连接的应用服务器譬如Tomcat无相应导致的</br>

5. HTTP 301和302状态有什么区别</br>
301 redirect: 301 代表永久性转移(Permanently Moved)</br>
302 redirect: 302 代表暂时性转移(Temporarily Moved )</br>
301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</br>

6. 互联网服务的默认端口是多少?</br>
HTTP 80 SMTP 25 POP3 110 FTP 21 20 TELNET 23</br>

7. TCP三次握手和四次挥手</br>
三次握手：</br>
第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</br>
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</br>
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</br>
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</br>
四次握手：</br>
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</br>
第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</br>
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</br>
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</br>
三次握手：为了防止已失效的链接请求报文段突然又传送到服务端，因而产生错误。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</br>
四次挥手：确保数据能够完成传输。</br>
但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</br>

8. TCP与UDP差别</br>
TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。</br>
TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</br>
TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</br>

9. 针对3次握手的恶意攻击，如何应对</br>
Dos(Denial of Service拒绝服务)攻击和DDos(Distributed Denial of Service)攻击 SYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器。这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做SYN timeout，这段时间大约30秒-2分钟左右。若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。</br>

10. 为什么连接的时候是三次握手，关闭的时候却是四次握手？</br>
这 是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。</br>
这是由于TCP的半关闭造成的，由于TCP 是全双工的，表示可以同时在两个方向上即可以接收数据也可以发送数据。所以我们关闭连接必须在每个方向上面单独关闭，这个单方向的关闭就叫半关闭。所以挥手时其实就是2次断开连接，所以是四次。</br>

11. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</br>
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</br>
Client端主动打开连接、主动关闭连接的情况：</br>
Client主动打开，SYN_SENT状态，发送SYN J，服务器收到进入SYN_RCVD状态，SYN K,ack J+1，客户端进入established状态，发送ack K+1，服务器端进入ESTABLISHED状态。</br>
客户端FIN_WAIT1状态，发送FIN M，服务器端进入CLOSE_WAIT状态，发送ack M+1，客户端FIN_WAIT2状态，当服务器端发送完LAST_ACK后，服务器端发送FIN N,客户端进入TIME_WAIT状态（在这个状态停留2MSL的时间，MSL：报文段最长生存时间），发送ackN+1.服务器端closed状态。</br>

12. HTTP1.0与HTTP1.1的差别</br>
HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</br>
HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</br>
HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</br>

13. TCP和UDP的区别</br>
1）TCP和UDP都是传输层的协议。</br>
2）TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于一次传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。比如FTP、SMTP之类</br>
3）UDP：面向非连接、传输不可靠、用于一次传输少量数据(数据包模式)、速度快</br>

14. 服务端session是如何标识已登录的用户的？</br>
http是无状态的会话，需要基于http协议支持会话状态的机制。这时候引入session，在会话开始时，分配一个唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后每次请求的时候，浏览器的cookie都会带上这个会话ID来告诉web服务器请求是属于哪个会话的。这也是为什么禁用了cookie之后，每次操作都需要先登录。在web服务器上各个会话有独立的存储，保存不同会话的信息。</br>
 
15. 对于上万个用于已经登录了，服务端是怎么分辨每个用户的？</br>
1) 服务器在响应头内加上”set-Cookie:XXXXXXXXXXXXX“(相当于一个唯一的ID符)，此信息是服务器随机生成的，放在服务器内存里，不会重复,这就是sessionid。</br>
2) 当浏览器得到这个sessionId会将它放在自己的进程内存里,.然后你继续发请求给这个网站的时候,浏览器就会把这个sessionId放在请求头里发送给该服务器了,这样服务器得到sessionId后再和自己内存里存放的sessionid对比锁定客户端,从而区分不同客户端,完成会话。</br>
3) 关闭浏览器结束进程,则这个sessionid将消失,如果用户又打开浏览器想继续这次会话的时候,就会因为发送的请求中没有这个sessionid，而使服务器无法辨别请求身份。</br>

16. 从浏览器打开百度，这个过程发生了什么？</br>
1）浏览器查询缓存，如果缓存存在跳到第11步；</br>
2）浏览器本地的host文件查看是否存在对应IP地址</br>
3）DNS域名解析，返回IP地址给浏览器</br>
4）浏览器打开对服务器的TCP连接</br>
5）浏览器通过TCP连接发送HTTP请求；</br>
6）CDN 缓存静态文件，是否存在，存在就直接返回；</br>
7）经过负载均衡服务器然后到达应用服务器（这里如果是面向服务的架构，可能存在服务调用）；</br>
8）浏览器检查HTTP响应是否为一个重定向（3xx 结果状态码 ），一个验证请（401），错误（4xx 5xx）等等，这些都是不同响应的正常处理（2xx）。
9）如果响应可缓存，将存入缓存</br>
10）浏览器解码响应（例如：如果它是gziped压缩），浏览器决定如何处理这些响应（例如，它是HTML页面，一张图片，一段音乐）</br>
11）浏览器展现响应，对未知类型还会弹出下载对话框（现在一般不会弹出了，用户对浏览器设置而定）</br>
note：这个题目其实是一个很好引导面试官的题目，在我们说完大致过程之后，我们可以选择自己熟悉地方引。比如</br>
1）  关于负载均衡，引导负载均衡的类型以及实现负载均衡的算法；</br>
2）比如session定位问题，引出session绑定、session复制、session服务器集群；</br>
3）比如关于缓存我们可以引出二八定律、一致性hash问题。</br>

17. 如果有万级别的session，怎么提高效率？</br>
专门的session服务器(redis或则memcache实现)，这里就有session在分布式环境下的问题，最后引出一致性hash问题。</br>

18. TCP的滑动窗口协议</br>
窗口合拢：窗口左边沿向右边沿靠近，发生在数据被发送和确认时；</br>
窗口张开：窗口右边沿向右移动时将允许发送更多的数据，发生在另一端的接受进程读取已经确认的数据并释放了TCP的接受缓存时</br>

19. 拥塞控制：慢启动、拥塞避免、快速恢复、快速重传。</br>
拥塞窗口：发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</br>
慢启动：该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。</br>

20. HTTPS和HTTP的区别</br>
https协议需要到ca申请证书，一般免费证书很少，需要交费。</br>
http 是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</br>
http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。</br>
http的连接很简单,是无状态的。</br>
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全。</br>

21. TCP如何保证可靠传输</br>
1) 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</br>
2) 数据校验</br>
3) 数据合理分片和排序：</br>
UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</br>
4) 流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</br>
5) 拥塞控制：当网络拥塞时，减少数据的发送。</br>

22. 请求header的content-length问题</br>
如果有人恶意伪造content-length很大的包头，但实际上发送content-length很小的请求，这样服务器会一直干等，直到超时。当然服务器是可以通过设置来避免该问题的</br>

23. GET和POST的安全性</br>
1) GET是通过URL方式请求，可以直接看到，明文传输。</br>
2) POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。 3.GET请求会保存在浏览器历史纪录中，还可能会保存在Web的日志中。</br>

24. 路由寻址</br>
1）搜索路由表，寻找能与目的IP地址完全匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</br>
2）搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</br>
3）搜索路由表，寻找default表目。如果找到，则把报文发送给该表目指定的下一站路由器。</br>
