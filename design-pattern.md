单例模式 （双重检查），饱汉与饿汉的区别</br>
单一职责：一个类只有一种职责</br>
开-闭原则：对扩展开放，对更改封闭</br>
里氏代换原则：只要是基类出现的地方，一定能出现子类</br>
依赖倒转原则：要针对接口编程不要针对实现编程，高层模块不应该依赖底层模块，两者应该依赖抽象。</br>
接口隔离原则：客户端不应该依赖它不需要的方法，类间的依赖关系应该建立在最小的接口上。</br>
迪米特原则：一个对象应当对其他对象有尽可能少的依赖</br>

创建型</br>
单例模式：一个类仅有一个实例，并提供一个访问它的全局访问点。</br>
工厂方法：某个对象的创建工作。</br>
抽象工厂：一系列互相依赖的对象的创建</br>
Builder模式:将一个复杂对象的构建与它的表示分离</br>
原型模式：对象的创建过程较为复杂并且有时需要频繁创建</br>

结构型</br>
适配器模式：将一个类的接口转换为另外一个接口。</br>
Bridge模式：将抽象部分和它的实现部分分离，使它们可以独立变化。</br>
Composite组合模式：将对象组合成属性结构以表示部分-整体的层次结构。</br>
装饰模式：动态的给一个对象添加一些额外的职责。</br>
外观模式：为子系统中的一组接口提供一个一致的界面。</br>
享元模式：运用共享技术有效地支持大量细粒度对象。</br>
代理模式：为其他对象提供一种代理以控制对这个对象的访问。</br>

行为型</br>
责任链模式：使多个对象都有机会处理请求从而避免请求的发送者和接收者之间的耦合关系。</br>
中介者模式:用一个中介对象来封装一系列的对象交互。</br>
备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态。</br>
观察则模式：定义对象间的一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并被更新。</br>

代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理类没有控制权，只能为其添加一层装饰，以加强被装饰对象的功能。</br>
单例，代理，享元，装饰，观察者这些模式天生就是为了优化系统而生</br>
抽象工厂和工厂最主要区别是建产品族，例如：女娲造人，要造黄种人，黑种人，就可以用工厂，要是他想造黄人女，黄人男，黑人女，黑人男，就要用抽象工厂，分产品族去构造</br>
装饰器模式是代理模式的一个特殊应用，代理模式侧重对代理过程的控制，装饰模式是对类的功能的加强或减弱，他着重类的功能变化。</br>
单例，代理可以实现延迟加载，享元共享对象拷贝，装饰避免继承带来的紧密耦合，观察者不用一直监控</br>