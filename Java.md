1. 为什么重载了equals方法之后需要去重载hashCode方法。</br>
Hash的时候需要保证equals的对象映射到同一个位置。
</br>
2. Java5, Java6, Java7, Java8有什么新特性</br>
Java5:</br>
1、泛型 Generics</br>
2、枚举类型 Enumeration</br>
3、自动装箱拆箱（自动类型包装和解包）</br>
4、可变参数varargs</br>
5、Annotations 它是Java中的metadata</br>
6、新的迭代语句（for(int n:numbers)）</br>
7、静态导入（import static ）</br>
8、新的格式化方法（java.util.Formatter）</br>
9、新的线程模型和并发库Thread Framework</br>
Java6:</br>
1、引入了一个支持脚本引擎的新框架</br>
2、UI的增强</br>
3、对WebService支持的增强（JAX-WS2.0和JAXB2.0）</br>
4、一系列新的安全相关的增强</br>
5、JDBC4.0</br>
6、Compiler API</br>
7、通用的Annotations支持</br>
Java7:</br>
1.switch中可以使用字串了</br>
2.运用List<String> tempList = new ArrayList<>(); 即泛型实例化类型自动推断</br>
3.语法上支持集合，而不一定是数组</br>
4.新增一些取环境信息的工具方法</br>
5.Boolean类型反转，空指针安全,参与位运算</br>
6.两个char间的equals</br>
Java8:</br>
1.接口的默认方法</br>
2.Lambda 表达式</br>
</br>
3. 基本类型与引用类型的区别</br>
基本类型：存放在栈空间中，未初始化时为随机值。</br>
引用类型：存放在堆空间中，未初始化时有默认的值。比如int未初始化时为0，boolean未初始化时为false。</br>
引用类型和原始类型的行为完全不同，分别具有不同的语义，并且具有不同的特征和用法，它们包括：大小和速度问题，使用原始类型无须调用 new，也无须创建对象，这节省了时间和空间。另外，对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</br>
</br>
4. 继承和多态的区别</br>
在继承关系中，父类更通用、子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。多态的特征是表现出多种形态，具有多种实现方式。或者多态是具有表现多种形态的能力的特征。或者同一个实现接口，使用不同的实例而执行不同的操作。</br>
</br>
5. final finalize finally 的区别</br>
final 用于声明属性，方法和类，分别表示属性不可变，方法不能覆盖，类不可继承。</br>
finally是异常处理语句结构的一部分，表示总是执行。</br>
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收。例如文件关闭等。JVM不保证此方法总被调用。finalize有严重的性能问题。</br>
</br>
6. String StringBuffer StringBuilder 区别</br>
StringBuilder是非线程安全的 StringBuffer是线程安全的 String和StringBuilder是效率以及内存分配问题。 </br>
String在循环中操作，会导致声明很多StringBuilder，因此禁止这种操作。String和StringBuilder在编译优化之后结果基本一致；</br>
</br>
7. Integer缓存?Integer比较大小注意问题</br>
Integer是有缓冲池的,java.lang.Integer.valueOf(int)方法默认情况下如果参数在-128到127之间,则返回缓存中的对象,否则返回new Integer(int)。java使用该机制是为了达到最小化数据输入和输出的目的,这是一种优化措施,提高效率。</br>
</br>
8. 怎么理解abstract class(抽象类)和interface(接口)</br>
抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。</br>
接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情</br>
</br>
9. “==”和equals方法的区别</br>
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相等。equlas方法是用于比较两个独立对象的内容是否相同。如果一个类没有定义自己的equlas方法，它默认的equlas方法就是使用==操作符。</br>
</br>
10. Java中实现多态的机制是什么？</br>
靠的是父类或者接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</br>
</br>
11. Java中异常处理机制的原理</br>
异常是指Java程序运行时所发生的非正常情况或错误。Java异常的根类为Throwable,Throwable下面又派生了两个子类Error和Exception,Error表示程序本身无法克服和恢复的一种严重问题。Exception分为受检异常和运行时异常。受检异常即使程序逻辑正常也可能由于程序上下文而导致发生异常。受检异常的特点在于它强制要求开发人员在代码中进行显示的声明和捕获，否则就会产生编译错误。</br>
ClassCastException(类转换异常)</br>
IndexOutOfBoundsException(数组越界)</br>
NullPointerException(空指针)</br>
IllegalArgumentException - 传递非法参数异常。</br>
</br>
12. Java 8中stream迭代的优势和区别？</br>
stream迭代可以发挥多核优势，可以并行处理，而不像外部迭代需要串行处理。</br>
</br>
13. Java泛型的实现原理</br>
java泛型的实现原理是类型擦除。Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</br>
</br>
14. 无限制通配符类型</br>
如果要使用泛型，但不确定或者不关心实际的类型参数，就可以使用一个问号代替。Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合。Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合。Set是个原生态类型。</br>
</br>
15. compareTo方法</br>
将这个对象与指定的对象进行比较。当该对象小于、等于或者大于指定对象的时候，分别返回一个负整数、零或者正整数。</br>
</br>
16. Object对象的常用方法</br>
clone方法  保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</br>
getClass方法  final方法，获得运行时类型。</br>
toString方法 该方法用得比较多，一般子类都有覆盖。</br>
finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</br>
equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</br>
超类已经覆盖了equals，从超类继承过来的行为对于子类也是适合的。类是私有的或是包级私有的，可以确定它的equlas方法永远不会调用。自反性 对称性 传递性 一致性</br>
hashCode方法 该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</br>
wait方法   wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</br>
notify方法 该方法唤醒在该对象上等待的某个线程。</br>
notifyAll方法 该方法唤醒在该对象上等待的所有线程。</br>
</br>
17. Java集合fail-fast</br>
机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</br>
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件</br>
</br>
18. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么</br>
Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</br>
</br>
19. ArrayList和LinkedList的区别,数据结构实现,扩容机制</br>
(1) ArrayList是实现了基于动态数组的数据结构,LinkedList基于双向循环链表的数据结构。 (2) 对于随机访问get和set,ArrayList觉得优于LinkedList,因为LinkedList要移动指针。 (3) 对于新增和删除操作add和remove,LinedList比较占优势,因为ArrayList要移动数据。 (4) 查找操作indexOf,lastIndexOf,contains等,两者差不多。 (5) 随机查找指定节点的操作get,ArrayList速度要快于LinkedList. 当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能;当你的操作是在 一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。 扩容: 针对ArrayList,在新增的时候,容量不够就需要扩容,1.5倍。 </br>
</br>
20. Vector和ArrayList的区别</br>
（1）  Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 （2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</br>
</br>
21. HashMap的实现原理</br>
HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</br>
(1)内部数据结构实现:数组+链表 (2)key值不能重复,只能put一个key为null的键值对。可以更深层次考察对put(null,value)以及get(null)的 理解。 (3)HashMap在put时,经过了两次hash,一个是JDK自带的对对象key的hash,然后再对结果使用HashMap内部函数hash(int h);hash(int h)方法根据key的hashCode重新计算一次散列。(4)在put时如果空间不够就需要扩容resize()
处理冲突的方法，开放地址法、再哈希法、链地址法</br>
JDK1.7使用的是拉链法 JDK1.8使用的红黑树 而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</br>
Java HashMap,已知整个生命周期内不会放入超过100个元素,那么占用内存大小最优且设置完初始值后无需自动扩容,该初始值应该设置为多少?</br>
如果默认使用HashMap内置的负载因子loadFactor为0.75。鉴于HashMap初始化设置大小为2的n次方,则100/0.75=133. 大于133的最小2的n次方为256个。 </br>
(1)直接寻址法:取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b为散列函数。若其中H(key)中已经有值了,就往下一个找,直到H(key)中没有值了,就放进去。 (2) 数字分析法:就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址。 (3)平方取中法:取关键字平方后的中间几位作为散列地址。 (4) 折叠法:将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(去除进位)作为散列地址。 (5)随机数法:选择一随机函数,取关键字的随机值作为散列地址,通常用于关键字长度不同的场合。(6)除留余数法:取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即H(key) = key MOD p,p<=m。不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。</br>
</br>
22. HashMap和Hashtable有什么区别？</br>
HashMap允许键和值是null，而Hashtable不允许键或者值是null。</br>
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</br>
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</br>
一般认为Hashtable是一个遗留的类。</br>
</br>
23. Java HashMap在高并发情况下不当使用,可能会导致什么样极端情况,为什么?</br>
在并发的多线程使用场景中,在resize扩容的时候,使得HashMap形成环链,造成死循环,CPU飙升至100%。</br>
</br>
24. HashTable</br>
HashTable继承Dictionary类，并且是线程安全的，任一时间只允许一个线程写HashTable.HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</br>
</br>
25. LinkedHashMap</br>
LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。LinkedHashMap实现与HashMap的不同之处在于,后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序,该迭代顺序可 以是插入顺序或者是访问顺序。最好画个图解释下。Entry对象在HashMap的时候包含key,value,hash值,以及一个next;而在LinkedHashMap中新增了before和after。 </br>
</br>
26. TreeMap</br>
TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</br>
</br>
27. ConcurrentHashMap原理</br>
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。每个Segment中有一个Entry数组，Entry中成员value是volatile修饰，其他成员通过final修饰。get操作不用加锁，put和remove操作需要加锁，因为value通过volatile保证可见性。</br>
</br>
28. HashMap的存放自定义类时，需要实现自定义类的什么方法？</br>
hashCode和equals。通过hash(hashCode)然后模运算（其实是与的位操作）定位在Entry数组中的下标，然后遍历这之后的链表，通过equals比较有没有相同的key，如果有直接覆盖value，如果没有就重新创建一个Entry。</br>
</br>
29. HashSet和TreeSet有什么区别？</br>
HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</br>
</br>
30. ThreadLocal实现原理</br>
Thread有一个成员是ThreadLocalMap，所以每次调用ThreadLocal的set和get方法都是从每个线程私有的ThreadLocalMap中进行插入获取元素。相当于每个线程都有自己的map，虽然线程都共享ThreadLocal这个键，但是都是从自己的map中进行获取元素，自然保证线程私有。ThreadLocalMap map = getMap(t);</br>
</br>
31. Java线程有哪些状态?</br>
创建，就绪，运行，阻塞，死亡。 </br>
第一是创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。  </br>
第二是就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 </br>
第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 </br>
第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 </br>
第五是死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</br>
blocked是内部对象锁阻塞,另外blocked激活需要线程调度器允许其持有对象,waiting是等待其他线程通知线程调度器一个条件; BLOCK产生的原因:I/O等待阻塞,suspend挂起等 </br>
WAITING产生原因:Thread.sleep,Object.wait等 </br>
</br>
32. Thread和Runnable的区别</br>
1、可以避免由于Java的单继承特性而带来的局限</br>
2、增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；</br>
3、适合多个相同程序代码的线程区处理同一资源的情况。</br>
</br>
33. 线程sleep()和yield()的区别是什么?</br>
sleep()使当前线程进入停滞状态,所以执行sleep()的线程在指定的时间内肯定不会执行;yield()只是使当前线程重新回到可执行状态,所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。sleep()可使优先级低的线程得到执行的机会,当然也可以让同优先级和高优先级的线程有执行的机会;yield()只能使同优先级的线程有执行的机会</br>
</br>
34. wait和sleep的区别?</br>
(1)sleep是Thread类的方法,是线程用来 控制自身流程的,比如有一个要报时的线程,每一秒中打印出一个时间,那么我就需要在print方法前面加上一个sleep让自己每隔一秒执行一次。 就像个闹钟一样。 wait是Object类的方法,用来线程间的通信,这个方法会使当前拥有该对象锁的进程等待直到其他线程调用notify方法时再醒来,不过你也可以给 他指定一个时间,自动醒来。这个方法主要是用走不同线程之间的调度的。 </br>
(2)关于锁的释放。调用sleep方法不会释放锁</br>
(3)使用区域  由于wait函数的特殊意义,所以他是应该放在同步语句块中的,这样才有意义 。</br>
</br>
35. CAS原理</br>
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。</br>
ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</br>
一写多读的情况主要需要考虑读到最新的数据,所以加volatile关键字即可 </br>
多写多读的情况就需要考虑原子操作,可以利用CAS原理 </br>
</br>
36. volatile和synchronized的区别</br>
volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。但不具备原子特性。</br>
禁止重排序以及底层通过插入内存屏障来实现的可见性和禁止重排序。</br>
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</br>
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</br>
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</br>
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</br>
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</br>
</br>
37. Synchronized和Lock的区别</br>
synchronized是java中的一个关键字当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：获取锁的线程执行完了该代码块，然后线程释放对锁的占有；线程执行发生异常，此时JVM会让线程自动释放锁。如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。5）Lock可以提高多个线程进行读操作的效率。Lock多出的三大优势（尝试非阻塞加锁，尝试超时加锁，尝试可相应中断加锁）</br>
</br>
38. 死锁的四个条件</br>
（1）互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</br>
</br>
39. 多次调用线程的start方法会怎么样?</br>
线程的start()只能被调用一次,否则会报java.lang.IllegalThreadStateException</br>
</br>
40. Java加锁方式</br>
对于普通同步方法，锁是当前实例对象。</br>
对于静态同步方法，锁是当前类的Class对象。</br>
对于同步方法块，锁是Synchonized括号里配置的对象。</br>
</br>
41. CountDownLatch和CyclicBarrier</br>
CountDownLatch允许一个或多个线程等待其他线程完成操作。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</br>
CyclicBarrier让一组线程到达一个屏障时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</br>
区别：首先CyclicBarrier可以使用多次，CountDownLatch只能使用一次，其次，Barrier是等待指定数量线程到达再继续处理；Latch是等待指定事件变为指定状态后发生再继续处理，对于CountDown就是计数减为0的事件。Barrier是等待指定数量任务完成，Latch是等待其他任务完成指定状态的改变再继续。</br>
CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。   CyclicBarrier        : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</br>
这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</br>
</br>
42. Class.forName和class loader的区别</br>
class.forName和classLoader都可用来对类进行加载。前者除了将类的.class文件加载到JVM中之外，还会对类进行解释，执行类的static块。而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newinstance才会去执行static块。</br>
</br>
43. java的类加载器体系结构和双亲委托机制</br>
ClassLoader体系结构</br>
BootstrapLoader 引导类加载器 Bootstrap加载器是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载%JAVA_HOME%/jre/lib以及%JAVA_HOME%/jre/classes中的类</br>
ExtClassLoader 扩展类加载器 它负责加载JRE的扩展路径中JAR的类包。</br>
AppClassLoader 系统类加载器 主要负责加载class path所指定的位置的类或者jar文档。</br>
双亲委派模型 </br>当一个加载器在加载某个类的时候先让父加载器去加载，父加载器再让父加载器加载，依次类推，如果所有的父加载器都不能加载，再由自己来加载，而如果此时自己也不能加载，则产生Java.lang.NoClassDefFoundError错误。委托模型最大的好处就是提高了Java的安全性，比如：如果加载器的父加载器已经加载了某个类，那么自己就不能再加载此类了，这样就使得一些与Java类库中同名的类不能加载进来。</br>
</br>
44. 内存泄露怎么产生的</br>
内存泄露是指无用对象持续占有内存或无用对象的内存得不到释放，从而造成的内存空间的浪费成为内存泄露。Java内存泄露的根本原因是长生命周期的对象持有短生命周期对象的引用就很有可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露发生的场景。</br>
静态集合类引起的内存泄露</br>
当集合里面的属性被修改后，remove()方法不起作用。</br>
监听器 释放对象的时候没有释放对应的监听器。</br>
各种连接未关闭</br>
内部类和外部模块的引用内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放</br>
</br>
45. JVM分区</br>
程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。</br>
Java虚拟机栈：与程序计数器一样也是线程私有的，它的生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口信息等。</br>
本地方法栈：与虚拟机栈锁发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。</br>
Java堆：Java堆是被所有线程共享的一块区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。</br>
方法区：是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</br>
运行时常量池：Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。</br>
</br>
46. Jvm堆内存区,有两个S区有什么作用?</br>
S区即Survivor区,位于年轻代。年轻代分三个区。一个Eden 区,两个Survivor 区。大部分对象在Eden 区中生成。当Eden 区满时,还存活的对象将被复制到Survivor 区(两个中的一个),当这个Survivor 区满时,此区的存活对象将被复制到另外一个Survivor 区,当这个Survivor 去也满了的时候,从第一个Survivor 区复制过来的并且此时还存活的对象,将被复制年老区(Tenured)。需要注意,Survivor 的两个区是对称的,没先后关系,所以同一个区中可能同时存在从Eden 复制过来对象,和从前一个Survivor 复制过来的对象,而复制到年老区的只有从第一个Survivor 去过来的对象。而且,Survivor 区总有一个是空的。比例为8：1：1，这样只浪费10/1的空间</br>
</br>
47. young gc和full gc触发条件</br>
young gc :eden空间不足 </br>
full gc :显示调用System.GC、永久代空间达到一定比例、老年代达到一定的比例、Permanet Generation空间满、CMS GC时出现promotion failed和concurrent mode failure、 RMI等的定时触发、YGC时的悲观策略、dump live的内存信息时</br>
</br>
48. 内存分配策略</br>
1)对象优先在Eden分配;2)大对象直接进入老年代;3)长期存活的对象将进入老年代;4)动态对象年龄判定</br>
49. 对象存活算法,常见的有哪几种</br>
(1)引用计数算法 </br>
原理:给对象添加一个引用计数器,每当有一个地方引用它时,计数器加1;引用失效时,计数器减1;计数器为0说明可被回收。 缺点:很难解决对象相互循环引用的问题(对象相互循环引用,但其实他们都已经没有用了。 </br>
(2)可达性分析算法 </br>
原理:通过一些列称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的。在java语言中,可作为GC Roots的对象包括下面几种:虚拟机栈(栈帧中的本地变量表)中引用的对象、方法区类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象</br>
</br>
50. 垃圾收集算法</br>
标记-清除 首先要标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</br>
复制 为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</br>
标记-整理 “标记”过程仍然与“标记-清理”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</br>
</br>
51. 线上环境JVM参数Xms Xmx是如何设置的, 如果大小是一至,为什么这样设置?</br>
Xmx设置JVM 的最大可用内存,Xms 设置JVM初始使用内存,一般Xmx和Xms相同,这是因为当Xmx内存空间不够用时,将进行扩容导致Full GC。将Xmx和Xms设置成相同的值,避免因Xms偏小导致频繁重新分配内存,影响应用使用。</br>
</br>
52. 判断对象是否可回收的可达性分析算法中，GC Roots有哪些？</br>
1）JVM栈中引用的对象 ；</br>
2）方法区中静态属性引用的对象</br>
3）方法区中常量引用的对象</br>
4）本地方法栈中JNI（即native方法）引用的对象</br>
</br>
53. 新生代、老年代、持久代分别指什么？</br>
新生代：主要用来存放新生的对象。</br>
老年代：主要用来存放应用程序中生命周期长的对象。</br>
持久代：主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。</br>
</br>
54. IO密集型和CPU密集型与线程池大小的关系</br>
任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程,如配置Ncpu+1个线程的线程池。IO密集型任务则 由于线程并不是一直在执行任务,则配置尽可能多的线程,如2*Ncpu。混合型的任务,如果可以拆分,则将其拆分成一个CPU密集型任务和一个I O密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐率要高于串行执行的吞吐率,如果这两个任务执行时间相差太大,则没必要进行分解。</br>
</br>
55. 线程池的实现原理</br>
线程池的作用是有效的降低频繁创建销毁线程所带来的额外开销。一般来说,线程池都是采用预创建的技术,在应用启动之初便预先创建一定数目 的线程。应用在运行的过程中,需要时可以从这些线程所组成的线程池里申请分配一个空闲的线程,来执行一定的任务,任务完成后,并不是将线 程销毁,而是将它返还给线程池,由线程池自行管理。如果线程池中预先分配的线程已经全部分配完毕,但此时又有新的任务请求,则线程池会动 态的创建新的线程去适应这个请求。当然,有可能,某些时段应用并不需要执行很多的任务,导致了线程池中的线程大多处于空闲的状态,为了节 省系统资源,线程池就需要动态的销毁其中的一部分空闲线程。因此,线程池都需要一个管理者,按照一定的要求去动态的维护其中线程的数目。 线程池将频繁创建和销毁线程所带来的开销分摊到了每个具体执行的任务上,执行的次数越多,则分摊到每个任务上的开销就越小。当然,如果线 程创建销毁所带来的开销与线程执行任务的开销相比微不足道,可以忽略不计,则线程池并没有使用的必要。</br>
</br>
56. ThreadPool中线程是如何做到重用的?</br>
线程池在执行execute方法的时候,会根据初始化参数的大小以及线程池已有的线程数,来创建核心线程或者把task塞入任务队列;其中创建的核 心线程创建后会启动,run方法内会执行一个runWork函数,此函数会不断地从任务队列中获取task执行。</br>
</br>
57. 线程池的好处</br>
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</br>
提高响应速度。当任务到达时</br>
，任何可以不需要等待线程创建就能立即执行。</br>
提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</br>
</br>
58. Java锁有哪些种类，以及区别</br>
偏向锁：优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适合场景是适用于只有一个线程访问同步块的场景。</br>
轻量级锁：优点是竞争的线程不会阻塞提高了程序的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适合场景追求响应时间，同步块执行速度非常快</br>
重量级锁：优点是线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间缓慢。适合场景是追求吞吐量，同步块执行速度较长。</br>
</br>
59. 动态代理和cglib实现的区别</br>
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</br>
主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler.InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。</br>
CGLIB是针对类实现代理，主要是指定的类生成一个之类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成final</br>
