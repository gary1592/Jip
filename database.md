1. 数据库为什么要使用MVCC,使用MVCC有什么缺点?</br>
Multi-Version Concurrency Control 多版本并发控制,因为锁机制是一种预防性的,读会阻塞写,写也会阻塞读,当锁定粒度较大,时间较长时并发性能就不会太好;而MVCC是一种 后验性的,读不阻塞写,写也不阻塞读,等到提交的时候才检验是否有冲突,由于没有锁,所以读写不会相互阻塞,从而大大提升了并发性能。 </br>
缺点:通过MVCC机制,虽然让数据变得可重复读,但我们读到的数据可能是历史数据,是不及时的数据,不是数据库当前的数据!这在一些对于 数据的时效特别敏感的业务中,就很可能出问题。</br>

2. 数据库事务</br>
原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。</br>
一致性：数据库总是从一个一致性的状态转移到另外一个一致性的状态。</br>
隔离性：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</br>
持久性：一旦事务提交，则其所作的修改就会永远保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</br>

3. B和B+树的区别</br>
B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</br>
B+树的时间复杂度为O(h) = Nlogd  N为元素个数，d为每个节点出度</br>
B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</br>
B+树的优点：</br>
非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</br>
叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</br>
B树的优点：</br>
对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</br>
因为B树的所有节点都是包含键和值的,这就导致了每个几点可以存储的内容就变少了,出度就少了,树的高度会增高,查询的 时候磁盘I/O会增多,影响性能。由于B+Tree内节点去掉了data域,因此可以拥有更大的出度,拥有更好的性能。 </br>

4. MySQL索引默认实现是用的什么数据结构,为什么采用这种? </br>
索引也是磁盘上的,磁盘的I/O存取的消耗是比内存高出几个数量级的,索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数,所以要尽量降 低树的高度。要降低树的高度,因此用多分支的树,并且要树的每层的节点尽量的多,B+树将一个节点的大小设为等于一个页,这样每个节点只需 要一次I/O就可以完全载入,由于B+Tree内节点去掉了data域,因此可以拥有更大的出度,拥有更好的性能。</br>

5. MySQL引擎MyISAM,InnoDB有什么区别,各有什么特点?</br>
MyISAM是非事务安全型的,而InnoDB是事务安全型的。 MyISAM锁的粒度是表级,而InnoDB支持行级锁定。 MyISAM支持全文类型索引,而InnoDB不支持全文索引。 MyISAM相对简单,所以在效率上要优于InnoDB,小型应用可以考虑使用MyISAM。 </br>
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。  </br>
InnoDB表比MyISAM表更安全,可以在保证数据不会丢失的情况下,切换非事务表到事务表(alter table tablename type=innodb)。</br> 
应用场景:</br>
MyISAM管理非事务表。它提供高速存储和检索,以及全文搜索能力。如果应用中需要执行大量的SELECT查询,那么MyISAM是更好的选择。 </br>
InnoDB用于事务处理应用程序,具有众多特性,包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作,则应该使用InnoDB, 这样可以提高多用户并发操作的性能。 </br>

6. 从性能上考虑,MySQL InnoDB 表主键如何选择,为什么?</br>
自增主键 </br>
InnoDB使用聚集索引,数据记录本身被存于主索引(一颗B+Tree)的叶子节点上。这就要求同一个叶子节点内(大小为一个内存页或磁盘页)的 各条数据记录按主键顺序存放,因此每当有一条新的记录插入时,MySQL会根据其主键将其插入适当的节点和位置,如果页面达到装载因子(Inno DB默认为15/16),则开辟一个新的页(节点)。如果表使用自增主键,那么每次插入新的记录,记录就会顺序添加到当前索引节点的后续位置, 当一页写满,就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构,近似顺序填满。由于每次插入时也不需要移动已有数据,因此效率很 高,也不会增加很多开销在维护索引上。 </br>
如果使用非自增主键(如果身份证号或学号等),由于每次插入主键的值近似于随机,因此每次新纪录都要被插到现有索引页得中间某个位置,此 时MySQL不得不为了将新记录插到合适位置而移动数据,甚至目标页面可能已经被回写到磁盘上而从缓存中清掉,此时又要从磁盘上读回来,这增 加了很多开销,同时频繁的移动、分页操作造成了大量的碎片,得到了不够紧凑的索引结构,后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面</br>

7. 左连接和右连接</br>
左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。</br>
右连接检索结果是tbl2的所有数据和tbl1中满足where 条件的数据。</br>
inner join 两张表中都有的数据才会显示</br>

8. 数据事务的四种隔离级别 </br>
READ UNCOMMITTED(未提交读):在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处。</br>
READ COMMITTED(提交读):大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。READ COMMITTED满足隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是可见的。这个级别有时候也叫做不可重复读。因为两次执行同样的查询，可能会得到不一样的结果。</br>
REPEATABLE READ(可重复读):REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结构是一致的。但是理论上，可重复读隔离级别还是无法解决幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围的记录，会产生幻行。可重复读是MySQL的默认事务隔离级别。</br>
SERIALIZABLE(可串行化):是最高的隔离级别。它通过强制事务串行执行，避免了幻读的问题。简单的说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁的争用。</br>
脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</br>
非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</br>
幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。</br>

9. InnoDB处理死锁的方式</br>
InnoDB目前处理死锁的方式是，将持有最少行级排它锁的事务进行回滚。</br>

10. 聚簇索引和非聚簇索引的区别</br>
聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正式因为如此，所以一个表最多只能有一个聚簇索引。</br>

11. 索引的优点</br>
创建唯一性索引，保证数据库表中每一行数据的唯一性 </br>
大大加快数据的检索速度，这也是创建索引的最主要的原因 </br>
加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 </br>
在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 </br>
通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</br>

12. 辅助索引</br>
在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行。</br>

13. UNDO和REDO</br>
undo log是把所有没有COMMIT的事务回滚到事务开始前的状态，系统崩溃时，可能有些事务还没COMMIT,在系统恢复时，这些没有COMMIT的事务就需要借助undo log来进行回滚。</br>
redo log是指在回放日志的时候把已经COMMIT的事务重做一遍，对于没有commit的事务按照abort处理，不进行任何操作。</br>

14. 数据库三范式</br>
第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。</br>
 第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 </br>
第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 </br>
第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</br>
